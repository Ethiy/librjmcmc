<?xml version="1.0" standalone="yes"?>
<library-reference id="schedules"><title>Schedules</title><header name="/home/mbredif/Documents/dev/librjmcmc/lib/rjmcmc/schedule/geometric_schedule.hpp"><namespace name="simulated_annealing"><class name="geometric_schedule"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This class is a model of the Schedule concept and implements a geometric schedule : <equation><title/><alt>\[T_i=T_0*\alpha^i\]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/form_2.png"/></imageobject><textobject role="tex"><phrase>\[T_i=T_0*\alpha^i\]</phrase></textobject></mediaobject></equation> This schedule does not guarantee that the simulated annealing will converge to the global optimum. It is however the most commonly used schedule with a decrease coefficient close to 1 (e.g. 0.99999). </para></description><typedef name="iterator_category"><type>std::input_iterator_tag</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="pointer"><type>value_type *</type></typedef><typedef name="reference"><type>value_type &amp;</type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>geometric_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator!=" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>geometric_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator*" cv="const"><type>value_type</type></method><method name="operator++" cv=""><type><classname>geometric_schedule</classname>&lt; T &gt; &amp;</type></method><method name="operator++" cv=""><type><classname>geometric_schedule</classname>&lt; T &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method><method name="alpha" cv="const"><type>value_type</type></method><method name="alpha" cv=""><type>void</type><parameter name="a"><paramtype>value_type</paramtype></parameter></method></method-group><constructor><parameter name="temp"><paramtype>value_type</paramtype><description><para>Initial temperature </para></description></parameter><parameter name="alpha"><paramtype>value_type</paramtype><description><para>Geometric decrease coefficient </para></description></parameter><description><para>
</para></description></constructor></class></namespace></header><header name="/home/mbredif/Documents/dev/librjmcmc/lib/rjmcmc/schedule/inverse_linear_schedule.hpp"><namespace name="simulated_annealing"><class name="inverse_linear_schedule"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This class is a model of the Schedule concept and implements an inverse linear schedule: <equation><title/><alt>\[\frac{1}{T_{i+1}}=\frac{1}{T_i}+\delta\]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/form_1.png"/></imageobject><textobject role="tex"><phrase>\[\frac{1}{T_{i+1}}=\frac{1}{T_i}+\delta\]</phrase></textobject></mediaobject></equation> </para></description><typedef name="iterator_category"><type>std::input_iterator_tag</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="pointer"><type>value_type *</type></typedef><typedef name="reference"><type>value_type &amp;</type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>inverse_linear_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator!=" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>inverse_linear_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator*" cv="const"><type>value_type</type></method><method name="operator++" cv=""><type><classname>inverse_linear_schedule</classname>&lt; T &gt; &amp;</type></method><method name="operator++" cv=""><type><classname>inverse_linear_schedule</classname>&lt; T &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method></method-group><constructor><parameter name="temp"><paramtype>value_type</paramtype><description><para>Initial temperature </para></description></parameter><parameter name="delta"><paramtype>value_type</paramtype><description><para>Inverse linear temperature step </para></description></parameter><description><para>
</para></description></constructor></class></namespace></header><header name="/home/mbredif/Documents/dev/librjmcmc/lib/rjmcmc/schedule/logarithmic_schedule.hpp"><namespace name="simulated_annealing"><class name="logarithmic_schedule"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This class is a model of the Schedule concept and implements a geometric schedule: <equation><title/><alt>\[T_i=\frac{T_0}{\log_2(2+i)}\]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/form_3.png"/></imageobject><textobject role="tex"><phrase>\[T_i=\frac{T_0}{\log_2(2+i)}\]</phrase></textobject></mediaobject></equation> This schedule guarantees that the simulated annealing will converge to the global optimum if the initial temperature is set sufficiently high. It is however usually too slow to converge in practice, leading to the usage of faster but suboptimal schedules. </para></description><typedef name="iterator_category"><type>std::input_iterator_tag</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="pointer"><type>value_type *</type></typedef><typedef name="reference"><type>value_type &amp;</type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>logarithmic_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator!=" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>logarithmic_schedule</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator*" cv="const"><type>value_type</type></method><method name="operator++" cv=""><type><classname>logarithmic_schedule</classname>&lt; T &gt; &amp;</type></method><method name="operator++" cv=""><type><classname>logarithmic_schedule</classname>&lt; T &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method></method-group><constructor><parameter name="temp"><paramtype>value_type</paramtype><description><para>Initial temperature </para></description></parameter><description><para>
</para></description></constructor></class></namespace></header><header name="/home/mbredif/Documents/dev/librjmcmc/lib/rjmcmc/schedule/step_schedule.hpp"><namespace name="simulated_annealing"><class name="step_schedule"><template>
      <template-type-parameter name="Schedule"/>
    </template><description><para>This class is a model of the Schedule concept and wraps another schedule by slowing it down n-fold : <equation><title/><alt>\[T'_i=T_{0}{\lfloor\frac{i}{n}\rfloor\]</alt><mediaobject><imageobject role="html"><imagedata format="PNG" align="center" fileref="images/form_0.png"/></imageobject><textobject role="tex"><phrase>\[T'_i=T_{0}{\lfloor\frac{i}{n}\rfloor\]</phrase></textobject></mediaobject></equation> This schedule is used to facilitate the convergence of the sampler at a fixed temperature as the temperature decrease is broken down into plateaus of size n. </para></description><typedef name="iterator_category"><type>std::input_iterator_tag</type></typedef><typedef name="value_type"><type>Schedule::value_type</type></typedef><typedef name="difference_type"><type>Schedule::difference_type</type></typedef><typedef name="pointer"><type>Schedule::pointer</type></typedef><typedef name="reference"><type>Schedule::reference</type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>step_schedule</classname>&lt; Schedule &gt; &amp;</paramtype></parameter></method><method name="operator!=" cv="const"><type>bool</type><parameter name="s"><paramtype>const <classname>step_schedule</classname>&lt; Schedule &gt; &amp;</paramtype></parameter></method><method name="operator*" cv="const"><type>value_type</type></method><method name="operator++" cv=""><type><classname>step_schedule</classname>&lt; Schedule &gt; &amp;</type></method><method name="operator++" cv=""><type><classname>step_schedule</classname>&lt; Schedule &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method></method-group><constructor><parameter name="n"><paramtype>int</paramtype><description><para>Iteration count between wrapped schedule incrementations </para></description></parameter><parameter name="schedule"><paramtype>const Schedule &amp;</paramtype><description><para>Wrapped schedule </para></description></parameter><description><para>
</para></description></constructor></class></namespace></header></library-reference>
